done

= Active Record -- Object-relational mapping in Rails

Active Record connects classes to relational database tables to establish an
almost zero-configuration persistence layer for applications. The library
provides a base class that, when subclassed, sets up a mapping between the new
class and an existing table in the database. In the context of an application,
these classes are commonly referred to as *models*. Models can also be
connected to other models; this is done by defining *associations*.

Active Record relies heavily on naming in that it uses class and association
names to establish mappings between respective database tables and foreign key
columns. Although these mappings can be defined explicitly, it's recommended
to follow naming conventions, especially when getting started with the
library.

You can read more about Active Record in the {Active Record Basics}[https://edgeguides.rubyonrails.org/active_record_basics.html] guide.

A short rundown of some of the major features:

* Automated mapping between classes and tables, attributes and columns.

   class Product < ActiveRecord::Base
   end

  {Learn more}[link:classes/ActiveRecord/Base.html]

The Product class is automatically mapped to the table named "products",
which might look like this:

   CREATE TABLE products (
     id bigint NOT NULL auto_increment,
     name varchar(255),
     PRIMARY KEY  (id)
   );

This would also define the following accessors: <tt>Product#name</tt> and
<tt>Product#name=(new_name)</tt>.


* Associations between objects defined by simple class methods.

   class Firm < ActiveRecord::Base
     has_many   :clients
     has_one    :account
     belongs_to :conglomerate
   end

  {Learn more}[link:classes/ActiveRecord/Associations/ClassMethods.html]


* Aggregations of value objects.

   class Account < ActiveRecord::Base
     composed_of :balance, class_name: 'Money',
                 mapping: %w(balance amount)
     composed_of :address,
                 mapping: [%w(address_street street), %w(address_city city)]
   end

  {Learn more}[link:classes/ActiveRecord/Aggregations/ClassMethods.html]


* Validation rules that can differ for new or existing objects.

    class Account < ActiveRecord::Base
      validates :subdomain, :name, :email_address, :password, presence: true
      validates :subdomain, uniqueness: true
      validates :terms_of_service, acceptance: true, on: :create
      validates :password, :email_address, confirmation: true, on: :create
    end

  {Learn more}[link:classes/ActiveRecord/Validations.html]


* Callbacks available for the entire life cycle (instantiation, saving, destroying, validating, etc.).

   class Person < ActiveRecord::Base
     before_destroy :invalidate_payment_plan
     # the `invalidate_payment_plan` method gets called just before Person#destroy
   end

  {Learn more}[link:classes/ActiveRecord/Callbacks.html]


* Inheritance hierarchies.

   class Company < ActiveRecord::Base; end
   class Firm < Company; end
   class Client < Company; end
   class PriorityClient < Client; end

  {Learn more}[link:classes/ActiveRecord/Base.html]


* Transactions.

    # Database transaction
    Account.transaction do
      david.withdrawal(100)
      mary.deposit(100)
    end

  {Learn more}[link:classes/ActiveRecord/Transactions/ClassMethods.html]


* Reflections on columns, associations, and aggregations.

    reflection = Firm.reflect_on_association(:clients)
    reflection.klass # => Client (class)
    Firm.columns # Returns an array of column descriptors for the firms table

  {Learn more}[link:classes/ActiveRecord/Reflection/ClassMethods.html]


* Database abstraction through simple adapters.

    # connect to SQLite3
    ActiveRecord::Base.establish_connection(adapter: 'sqlite3', database: 'dbfile.sqlite3')

    # connect to MySQL with authentication
    ActiveRecord::Base.establish_connection(
      adapter:  'mysql2',
      host:     'localhost',
      username: 'me',
      password: 'secret',
      database: 'activerecord'
    )

  {Learn more}[link:classes/ActiveRecord/Base.html] and read about the built-in support for
  MySQL[link:classes/ActiveRecord/ConnectionAdapters/Mysql2Adapter.html],
  PostgreSQL[link:classes/ActiveRecord/ConnectionAdapters/PostgreSQLAdapter.html], and
  SQLite3[link:classes/ActiveRecord/ConnectionAdapters/SQLite3Adapter.html].


* Logging support for Log4r[https://github.com/colbygk/log4r] and Logger[https://ruby-doc.org/stdlib/libdoc/logger/rdoc/].

    ActiveRecord::Base.logger = ActiveSupport::Logger.new(STDOUT)
    ActiveRecord::Base.logger = Log4r::Logger.new('Application Log')


* Database agnostic schema management with Migrations.

    class AddSystemSettings < ActiveRecord::Migration[6.0]
      def up
        create_table :system_settings do |t|
          t.string  :name
          t.string  :label
          t.text    :value
          t.string  :type
          t.integer :position
        end

        SystemSetting.create name: 'notice', label: 'Use notice?', value: 1
      end

      def down
        drop_table :system_settings
      end
    end

  {Learn more}[link:classes/ActiveRecord/Migration.html]


== Philosophy

Active Record is an implementation of the object-relational mapping (ORM)
pattern[https://www.martinfowler.com/eaaCatalog/activeRecord.html] by the same
name described by Martin Fowler:

  "An object that wraps a row in a database table or view,
  encapsulates the database access, and adds domain logic on that data."

Active Record attempts to provide a coherent wrapper as a solution for the inconvenience that is
object-relational mapping. The prime directive for this mapping has been to minimize
the amount of code needed to build a real-world domain model. This is made possible
by relying on a number of conventions that make it easy for Active Record to infer
complex relations and structures from a minimal amount of explicit direction.

Convention over Configuration:
* No XML files!
* Lots of reflection and run-time extension
* Magic is not inherently a bad word

Admit the Database:
* Lets you drop down to SQL for odd cases and performance
* Doesn't attempt to duplicate or replace data definitions


== Download and installation

The latest version of Active Record can be installed with RubyGems:

  $ gem install activerecord

Source code can be downloaded as part of the Rails project on GitHub:

* https://github.com/rails/rails/tree/master/activerecord


== License

Active Record is released under the MIT license:

* https://opensource.org/licenses/MIT


== Support

API documentation is at:

* https://api.rubyonrails.org

Bug reports for the Ruby on Rails project can be filed here:

* https://github.com/rails/rails/issues

Feature requests should be discussed on the rails-core mailing list here:

* https://discuss.rubyonrails.org/c/rubyonrails-core

= Active Record-Railsのオブジェクトリレーショナルマッピング

Active Recordは、クラスをリレーショナルデータベーステーブルに接続して、
アプリケーションの構成がほぼゼロの永続化レイヤー。図書館
サブクラス化されると、新しいクラス間のマッピングを設定する基本クラスを提供します
クラスとデータベース内の既存のテーブル。アプリケーションのコンテキストでは、
これらのクラスは一般に*モデル*と呼ばれます。モデルもすることができます
他のモデルに接続されています。これは* associations *を定義することで行われます。

アクティブレコードは、クラスと関連付けを使用するという点でネーミングに大きく依存しています
それぞれのデータベーステーブルと外部キー間のマッピングを確立するための名前
列。これらのマッピングは明示的に定義できますが、推奨されます
命名規則に従う必要があります。特に、
図書館。

アクティブレコードについて詳しくは、{アクティブレコードの基本} [https://edgeguides.rubyonrails.org/active_record_basics.html]ガイドをご覧ください。

主な機能のいくつかの短い要約：

*クラスとテーブル、属性、列の間の自動マッピング。

   クラスProduct <ActiveRecord :: Base
   終わり

  {詳細} [link：classes / ActiveRecord / Base.html]

Productクラスは、「products」という名前のテーブルに自動的にマッピングされます。
これは次のようになります。

   CREATE TABLE製品（
     id bigint NOT NULL auto_increment、
     名前varchar（255）、
     プライマリキー（ID）
   ）;

これにより、次のアクセサーも定義されます：<tt> Product＃name </ tt>および
<tt> Product＃name =（new_name）</ tt>。


*単純なクラスメソッドによって定義されたオブジェクト間の関連付け。

   クラス会社<ActiveRecord :: Base
     has_many：clients
     has_one：account
     belongs_to：conglomerate
   終わり

  {詳細} [link：classes / ActiveRecord / Associations / ClassMethods.html]


*値オブジェクトの集計。

   クラスAccount <ActiveRecord :: Base
     composite_of：balance、class_name： 'お金'、
                 マッピング：％w（バランス量）
     composite_of：address、
                 マッピング：[％w（address_street street）、％w（address_city city）]
   終わり

  {詳細} [link：classes / ActiveRecord / Aggregations / ClassMethods.html]


*新しいオブジェクトと既存のオブジェクトで異なる検証ルール。

    クラスAccount <ActiveRecord :: Base
      ：subdomain、：name、：email_address、：password、presence：trueを検証します
      検証：サブドメイン、一意性：true
      検証：terms_of_service、受け入れ：true、on :: create
      ：password、：email_address、confirmation：true、on：：createを検証します
    終わり

  {詳細} [link：classes / ActiveRecord / Validations.html]


*ライフサイクル全体で利用できるコールバック（インスタンス化、保存、破棄、検証など）。

   クラスPerson <ActiveRecord :: Base
     before_destroy：invalidate_payment_plan
     ＃ `invalidate_payment_plan`メソッドはPerson＃destroyの直前に呼び出されます
   終わり

  {詳細} [link：classes / ActiveRecord / Callbacks.html]


*継承階層。

   クラスCompany <ActiveRecord :: Base;終わり
   クラス会社<会社;終わり
   クラスClient <Company;終わり
   クラスPriorityClient <クライアント;終わり

  {詳細} [link：classes / ActiveRecord / Base.html]


*トランザクション。

    ＃データベーストランザクション
    Account.transaction do
      david.withdrawal（100）
      mary.deposit（100）
    終わり

  {詳細} [link：classes / ActiveRecord / Transactions / ClassMethods.html]


*列、関連付け、および集計に関する考察。

    リフレクション= Firm.reflect_on_association（：clients）
    Reflection.klass＃=>クライアント（クラス）
    Firm.columns＃企業テーブルの列記述子の配列を返します

  {詳細} [link：classes / ActiveRecord / Reflection / ClassMethods.html]


*シンプルなアダプターによるデータベースの抽象化。

    ＃SQLite3に接続
    ActiveRecord :: Base.establish_connection（アダプター： 'sqlite3'、データベース： 'dbfile.sqlite3'）

    ＃認証でMySQLに接続する
    ActiveRecord :: Base.establish_connection（
      アダプター： 'mysql2'、
      ホスト： 'localhost'、
      ユーザー名： '私'、
      パスワード： 'secret'、
      データベース： 'activerecord'
    ）

  {詳細} [link：classes / ActiveRecord / Base.html]および組み込みのサポートについて読む
  MySQL [link：classes / ActiveRecord / ConnectionAdapters / Mysql2Adapter.html]、
  PostgreSQL [link：classes / ActiveRecord / ConnectionAdapters / PostgreSQLAdapter.html]、および
  SQLite3 [link：classes / ActiveRecord / ConnectionAdapters / SQLite3Adapter.html]。


* Log4r [https://github.com/colbygk/log4r]およびLogger [https://ruby-doc.org/stdlib/libdoc/logger/rdoc/]のロギングサポート。

    ActiveRecord :: Base.logger = ActiveSupport :: Logger.new（STDOUT）
    ActiveRecord :: Base.logger = Log4r :: Logger.new（ 'Application Log'）


* Migrationsによるデータベースにとらわれないスキーマ管理。

    クラスAddSystemSettings <ActiveRecord :: Migration [6.0]
      防御する
        create_table：system_settings do | t |
          t.string：name
          t.string：label
          t.text：value
          t.string：type
          t.integer：position
        終わり

        SystemSetting.create名前： '通知'、ラベル： 'Use  notice？ '、値：1
           終わり

           デフダウン
             drop_table：system_settings
           終わり
         終わり

       {詳細} [link：classes / ActiveRecord / Migration.html]


==哲学

アクティブレコードは、オブジェクトリレーショナルマッピング（ORM）の実装です。
同じパターン[https://www.martinfowler.com/eaaCatalog/activeRecord.html]
マーティンファウラーが説明した名前：

 「データベースのテーブルまたはビューの行をラップするオブジェクト、
 データベースアクセスをカプセル化し、そのデータにドメインロジックを追加します。」

Active Recordは、不便さの解決策として一貫したラッパーを提供しようとします
オブジェクトリレーショナルマッピング。このマッピングの主要な指示は、
実際のドメインモデルを構築するために必要なコードの量。これが可能になります
Active Recordが推論することを容易にする多くの規則に依存することによって
最小限の量の明示的な方向からの複雑な関係と構造。

構成に関する規約：
* XMLファイルはありません！
*多くのリフレクションとランタイム拡張
*魔法は本質的に悪い言葉ではありません

データベースを認める：
*奇妙なケースとパフォーマンスのためにSQLにドロップダウンできます
*データ定義を複製または置換しようとしない


==ダウンロードとインストール

最新バージョンのActive RecordはRubyGemsでインストールできます。

 $ gem install activerecord

ソースコードは、GitHubのRailsプロジェクトの一部としてダウンロードできます。

* https://github.com/rails/rails/tree/master/activerecord


==ライセンス

Active RecordはMITライセンスでリリースされています：

* https://opensource.org/licenses/MIT


==サポート

APIドキュメントは次の場所にあります。

* https://api.rubyonrails.org

Ruby on Railsプロジェクトのバグレポートはこちらから提出できます。

* https://github.com/rails/rails/issues

機能のリクエストは、以下のrails-coreメーリングリストで議論する必要があります。

* https://discuss.rubyonrails.org/c/rubyonrails-core